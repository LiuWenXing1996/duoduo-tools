import {
  addTypeTemplate,
  createResolver,
  defineNuxtModule,
  resolvePath,
  updateTemplates,
} from "nuxt/kit";
import { debounce } from "perfect-debounce";
import fs from "node:fs/promises";
import path from "node:path";
import { pascalCase } from "change-case";
import type { Nuxt } from "nuxt/schema";
import fsExtra from "fs-extra";

const listFiles = async (dir?: string) => {
  const files: string[] = [];
  if (!dir) {
    return [];
  }
  const getFiles = async (currentDir: string) => {
    const fileList = (await fs.readdir(currentDir)) as string[];
    for (const file of fileList) {
      if (![".DS_Store"].includes(file)) {
        const name = path.join(currentDir, file);
        if ((await fs.stat(name)).isDirectory()) {
          await getFiles(name);
        } else {
          files.push(name);
        }
      }
    }
  };
  await getFiles(dir);
  return files;
};

const isSub = (parent: string, dir: string) => {
  const relative = path.relative(parent, dir);
  return Boolean(
    relative && !relative.startsWith("..") && !path.isAbsolute(relative)
  );
};

export type FileInfo = {
  absolutePath: string;
  restPath: string;
};

export interface Options {
  dirs: OptionsDir[];
}

export interface OptionsDir {
  path: string;
  import: string;
  prefix: string;
  suffix: string;
}

const registerDir = async (params: {
  dir: OptionsDir;
  outDir: string;
  index: number;
  options: Options;
  nuxt: Nuxt;
}) => {
  const { nuxt, dir, index, outDir, options } = params;
  const buildDir = nuxt.options.buildDir;
  let toolFileInfoList: FileInfo[] = [];
  const absolutePath = await resolvePath(dir.path);
  const fileName = path.join(outDir, `${index}.d.ts`) as `${string}.d.ts`;

  addTypeTemplate({
    filename: fileName,
    getContents: () => /* Generated by auto-import-types */ `
export {}
declare global {
      ${toolFileInfoList
        .map((fileInfo) => {
          const extname = path.extname(fileInfo.restPath);
          let name = fileInfo.restPath.slice(
            0,
            fileInfo.restPath.length - extname.length
          );
          if (name.endsWith("index")) {
            name = name.slice(0, name.length - "index".length);
          }
          const typeName = pascalCase(`${dir.prefix}-${name}-${dir.suffix}`);
          const targetPath = path.relative(
            path.join(buildDir, outDir),
            fileInfo.absolutePath
          );
          return `  
import("${targetPath}")          
export type { ${dir.import} as ${typeName}} from "${targetPath}"`;
        })
        .join("\n")}
}
        `,
  });

  const scanFiles = debounce(async () => {
    const files = await listFiles(absolutePath);
    toolFileInfoList = files.map((fileName) => {
      const restFilename = path.relative(absolutePath, fileName);
      return {
        restPath: restFilename,
        absolutePath: fileName,
      };
    });
    await updateTemplates({
      filter: (e) => e.filename === fileName,
    });
  }, 25);

  await scanFiles();
  nuxt.hook("builder:watch", async (event, changePath) => {
    const srcDir = nuxt.options.srcDir;
    const absoluteChangePath = path.resolve(srcDir, changePath);
    // console.log({
    //   srcDir,
    //   absoluteChangePath,
    //   event,
    //   changePath,
    //   rest,
    // });
    if (isSub(absolutePath, absoluteChangePath)) {
      console.log(
        `auto-import-types re scan ${absolutePath} when ${absoluteChangePath} change`
      );
      scanFiles();
    }
  });
};

export default defineNuxtModule<Options>({
  meta: {
    name: "auto-import-types",
    configKey: "autoImportTypes",
  },
  defaults: {
    dirs: [],
  },
  setup: async (options, nuxt) => {
    const { dirs } = options;
    const buildDir = nuxt.options.buildDir;
    const outDir = "./auto-import-types";
    await fsExtra.emptyDir(path.join(buildDir, outDir));
    for (let index = 0; index < dirs.length; index++) {
      const dir = dirs[index];
      await registerDir({
        dir,
        index,
        outDir,
        options,
        nuxt,
      });
    }
  },
});
